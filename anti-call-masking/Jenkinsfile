// Jenkinsfile for Anti-Call Masking Detection System
// Declarative Pipeline for CI/CD

pipeline {
    agent {
        kubernetes {
            yaml '''
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: docker
    image: docker:24-dind
    securityContext:
      privileged: true
    volumeMounts:
    - name: docker-socket
      mountPath: /var/run/docker.sock
  - name: kubectl
    image: bitnami/kubectl:1.28
    command: ['cat']
    tty: true
  - name: trivy
    image: aquasec/trivy:latest
    command: ['cat']
    tty: true
  volumes:
  - name: docker-socket
    hostPath:
      path: /var/run/docker.sock
'''
        }
    }

    environment {
        REGISTRY = 'ghcr.io'
        IMAGE_NAME = 'abiolaogu/anti_call-masking'
        DOCKER_CREDENTIALS = credentials('docker-registry-credentials')
        KUBECONFIG_CREDENTIALS = credentials('kubeconfig')
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    stages {
        // =====================================================================
        // Stage: Checkout
        // =====================================================================
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    env.GIT_BRANCH_NAME = sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                }
            }
        }

        // =====================================================================
        // Stage: Code Quality
        // =====================================================================
        stage('Code Quality') {
            parallel {
                stage('Syntax Check') {
                    steps {
                        sh '''
                            echo "Checking q file syntax..."
                            for f in anti-call-masking/src/*.q; do
                                echo "Validating $f"
                                # Check balanced braces
                                open=$(grep -o '{' "$f" | wc -l)
                                close=$(grep -o '}' "$f" | wc -l)
                                if [ "$open" -ne "$close" ]; then
                                    echo "ERROR: Unbalanced braces in $f"
                                    exit 1
                                fi
                            done
                            echo "Syntax check passed"
                        '''
                    }
                }

                stage('Secrets Scan') {
                    steps {
                        sh '''
                            echo "Scanning for secrets..."
                            # Check for hardcoded passwords
                            if grep -rn "password.*=.*['\"][^'\"]*['\"]" --include="*.q" anti-call-masking/src/; then
                                echo "WARNING: Potential hardcoded passwords found"
                            fi
                            echo "Secrets scan completed"
                        '''
                    }
                }

                stage('YAML Validation') {
                    steps {
                        sh '''
                            echo "Validating Kubernetes manifests..."
                            cd anti-call-masking/k8s
                            for f in *.yaml; do
                                echo "Validating $f"
                                kubectl --dry-run=client -o yaml apply -f "$f" || true
                            done
                        '''
                    }
                }
            }
        }

        // =====================================================================
        // Stage: Security Scanning
        // =====================================================================
        stage('Security Scan') {
            steps {
                container('trivy') {
                    sh '''
                        echo "Running Trivy filesystem scan..."
                        trivy fs --severity HIGH,CRITICAL \
                            --exit-code 0 \
                            --format table \
                            anti-call-masking/
                    '''
                }
            }
        }

        // =====================================================================
        // Stage: Build Docker Image
        // =====================================================================
        stage('Build') {
            steps {
                container('docker') {
                    sh '''
                        echo "Building Docker image..."
                        cd anti-call-masking
                        docker build \
                            --tag ${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT} \
                            --tag ${REGISTRY}/${IMAGE_NAME}:${GIT_BRANCH_NAME} \
                            --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
                            --build-arg VCS_REF=${GIT_COMMIT_SHORT} \
                            .
                    '''
                }
            }
        }

        // =====================================================================
        // Stage: Image Security Scan
        // =====================================================================
        stage('Image Scan') {
            steps {
                container('trivy') {
                    sh '''
                        echo "Scanning Docker image for vulnerabilities..."
                        trivy image --severity HIGH,CRITICAL \
                            --exit-code 0 \
                            --format table \
                            ${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT}
                    '''
                }
            }
        }

        // =====================================================================
        // Stage: Push to Registry
        // =====================================================================
        stage('Push') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    branch pattern: 'release/*', comparator: 'GLOB'
                }
            }
            steps {
                container('docker') {
                    sh '''
                        echo "Pushing to container registry..."
                        echo ${DOCKER_CREDENTIALS_PSW} | docker login ${REGISTRY} -u ${DOCKER_CREDENTIALS_USR} --password-stdin
                        docker push ${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT}
                        docker push ${REGISTRY}/${IMAGE_NAME}:${GIT_BRANCH_NAME}

                        if [ "${GIT_BRANCH_NAME}" = "main" ]; then
                            docker tag ${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT} ${REGISTRY}/${IMAGE_NAME}:latest
                            docker push ${REGISTRY}/${IMAGE_NAME}:latest
                        fi
                    '''
                }
            }
        }

        // =====================================================================
        // Stage: Deploy to Staging
        // =====================================================================
        stage('Deploy Staging') {
            when {
                branch 'develop'
            }
            steps {
                container('kubectl') {
                    sh '''
                        echo "Deploying to staging..."
                        export KUBECONFIG=${KUBECONFIG_CREDENTIALS}

                        cd anti-call-masking/k8s

                        # Update image tag
                        kubectl set image deployment/fraud-detection \
                            fraud-detection=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT} \
                            -n fraud-detection-staging

                        # Wait for rollout
                        kubectl rollout status deployment/fraud-detection \
                            -n fraud-detection-staging \
                            --timeout=300s
                    '''
                }
            }
        }

        // =====================================================================
        // Stage: Deploy to Production
        // =====================================================================
        stage('Deploy Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Deploy"
                parameters {
                    booleanParam(name: 'CONFIRM', defaultValue: false, description: 'Confirm deployment')
                }
            }
            steps {
                container('kubectl') {
                    sh '''
                        echo "Deploying to production..."
                        export KUBECONFIG=${KUBECONFIG_CREDENTIALS}

                        cd anti-call-masking/k8s

                        # Apply kustomization
                        kubectl apply -k .

                        # Update image tag
                        kubectl set image deployment/fraud-detection \
                            fraud-detection=${REGISTRY}/${IMAGE_NAME}:${GIT_COMMIT_SHORT} \
                            -n fraud-detection

                        # Wait for rollout
                        kubectl rollout status deployment/fraud-detection \
                            -n fraud-detection \
                            --timeout=300s

                        echo "Production deployment complete"
                    '''
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }

        success {
            echo 'Pipeline completed successfully!'
            // slackSend(channel: '#deployments', message: "SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }

        failure {
            echo 'Pipeline failed!'
            // slackSend(channel: '#deployments', message: "FAILED: ${env.JOB_NAME} #${env.BUILD_NUMBER}")
        }

        unstable {
            echo 'Pipeline unstable!'
        }
    }
}
