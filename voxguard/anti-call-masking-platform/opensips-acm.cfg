####### OpenSIPS Anti-Call Masking Configuration #######
####### Nigerian ICL Interconnect Clearinghouse #######
####### Version: 2.0 | Date: 2026-01-22 #######

####### Global Parameters #######

# Logging
log_level=3
log_stderror=no
log_facility=LOG_LOCAL0

# Process management
children=16
auto_scaling_profile = ACM
auto_scaling_cycle = 1
auto_scaling_terminate_after = 15

# TCP/UDP settings
listen=udp:eth0:5060
listen=tcp:eth0:5060
listen=tls:eth0:5061

# TLS settings
tls_verify_server=0
tls_verify_client=0
tls_require_client_certificate=0
tls_method=TLSv1_2+

# Memory settings
user_agent_header="OpenSIPS-ACM/2.0"
server_header="OpenSIPS-ACM/2.0"

# Timer settings
tcp_connection_lifetime=120
tcp_max_connections=4096
tcp_keepalive=1
tcp_keepidle=30
tcp_keepinterval=10
tcp_keepcount=3

# DNS settings
dns=no
rev_dns=no
dns_try_ipv6=no
use_dns_cache=on
dns_cache_del_nonexp=no

####### Modules Section #######

# Core modules
loadmodule "signaling.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "sipmsgops.so"
loadmodule "uri.so"
loadmodule "db_postgres.so"

# Dialog and accounting
loadmodule "dialog.so"
loadmodule "acc.so"

# Authentication and permissions
loadmodule "auth.so"
loadmodule "permissions.so"
loadmodule "drouting.so"
loadmodule "dispatcher.so"

# NAT handling
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"

# HTTP and REST for ACM Engine
loadmodule "rest_client.so"
loadmodule "json.so"

# Caching (DragonflyDB/Redis)
loadmodule "cachedb_redis.so"

# Rate limiting
loadmodule "ratelimit.so"
loadmodule "pike.so"

# Statistics and tracing
loadmodule "statistics.so"
loadmodule "siptrace.so"
loadmodule "mi_fifo.so"

####### Module Parameters #######

# TM parameters
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)

# RR parameters
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Dialog parameters
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 2)
modparam("dialog", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("dialog", "profiles_with_value", "caller")
modparam("dialog", "cachedb_url", "redis://dragonfly:6379/")

# Permissions (Gateway Groups)
modparam("permissions", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("permissions", "address_table", "address")

# Dynamic Routing
modparam("drouting", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("drouting", "use_domain", 0)
modparam("drouting", "sort_order", 1)

# Dispatcher (Load balancing media gateways)
modparam("dispatcher", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_mode", 1)

# ACC (CDR accounting)
modparam("acc", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("acc", "early_media", 1)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 1)
modparam("acc", "db_flag", "ACC_DB")
modparam("acc", "db_missed_flag", "ACC_MISSED")
modparam("acc", "cdr_flag", "CDR")
modparam("acc", "db_extra", "caller_id=$fU;called_number=$rU;source_ip=$si;fraud_detected=$avp(fraud_detected);fraud_type=$avp(fraud_type)")

# DragonflyDB cache
modparam("cachedb_redis", "cachedb_url", "redis:acm://dragonfly:6379/")

# REST client for ACM Detection Engine
modparam("rest_client", "connection_timeout", 500)  # 500ms max
modparam("rest_client", "curl_timeout", 1000)       # 1s max
modparam("rest_client", "max_async_transfers", 256)

# Rate limiting (calls per second per source)
modparam("ratelimit", "timer_interval", 1)
modparam("ratelimit", "default_algorithm", "SBT")
modparam("ratelimit", "cachedb_url", "redis:acm://dragonfly:6379/")
modparam("ratelimit", "pipe_replication_cluster", "acm_cluster")

# Pike (anti-flood)
modparam("pike", "sampling_time_unit", 1)
modparam("pike", "reqs_density_per_unit", 100)
modparam("pike", "remove_latency", 120)
modparam("pike", "pike_log_level", 1)

# SIP tracing (Homer)
modparam("siptrace", "trace_id", "[tid]homer_hep")
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "traced_user_avp", "$avp(traced_user)")

# MI FIFO
modparam("mi_fifo", "fifo_name", "/tmp/opensips_acm_fifo")

####### Routing Logic #######

route {
    # Initial sanity checks
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Anti-flood protection
    if (!pike_check_req()) {
        xlog("L_WARN", "PIKE: Flood detected from $si\n");
        sl_send_reply(503, "Service Unavailable - Rate Limited");
        exit;
    }

    # NAT detection and handling
    force_rport();
    if (nat_uac_test(19)) {
        fix_nated_contact();
        setflag(NAT);
    }

    # Record route for in-dialog requests
    if (has_totag()) {
        if (is_method("INVITE|ACK")) {
            record_route();
        }
        route(sequential);
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Initial request processing
    t_check_trans();

    # Only INVITE processing goes through fraud detection
    if (is_method("INVITE")) {
        # Create dialog for CDR
        create_dialog();
        setflag(CDR);
        setflag(ACC_DB);

        # ==== ANTI-CALL MASKING DETECTION ====
        route(acm_detect);

        # Check if fraud was detected
        if ($avp(fraud_detected) == 1) {
            route(handle_fraud);
            exit;
        }

        # MNP lookup for Nigerian numbers
        if ($rU =~ "^234[0-9]{10}$") {
            route(mnp_lookup);
        }

        # Dynamic routing
        route(route_call);
    }

    # REGISTER handling
    if (is_method("REGISTER")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # OPTIONS ping handling
    if (is_method("OPTIONS")) {
        sl_send_reply(200, "OK");
        exit;
    }

    # Default reject
    sl_send_reply(501, "Not Implemented");
    exit;
}

# Sequential request handling (in-dialog)
route[sequential] {
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(ACC_DB);
        }
        t_relay();
    } else {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                t_relay();
            }
        } else {
            sl_send_reply(404, "Not Found");
        }
    }
    exit;
}

# ==== ANTI-CALL MASKING DETECTION ROUTE ====
route[acm_detect] {
    $avp(fraud_detected) = 0;
    $avp(fraud_type) = "NONE";
    $avp(fraud_confidence) = 0;
    $avp(fraud_action) = "allow";

    # Step 1: Check gateway group (permissions)
    $var(src_grp) = 0;
    if (check_source_address(1)) {
        # Group 1: Trusted local carriers
        $var(src_grp) = 1;
    } else if (check_source_address(10)) {
        # Group 10: International gateways
        $var(src_grp) = 10;
    } else if (check_source_address(66)) {
        # Group 66: Blacklisted
        $var(src_grp) = 66;
        xlog("L_WARN", "ACM: Blacklisted source $si attempting call\n");
        $avp(fraud_detected) = 1;
        $avp(fraud_type) = "BLACKLIST";
        $avp(fraud_confidence) = 100;
        $avp(fraud_action) = "block";
        return;
    }

    # Step 2: Fast-path CLI validation (Nigerian number from international gateway)
    if ($var(src_grp) == 10) {
        # Check if CLI is Nigerian (+234 or 234)
        if ($fU =~ "^\+?234[0-9]{10}$") {
            xlog("L_WARN", "ACM: Call masking detected! International gateway $si sending Nigerian CLI $fU\n");
            $avp(fraud_detected) = 1;
            $avp(fraud_type) = "CLI_MASK";
            $avp(fraud_confidence) = 95;
            $avp(fraud_action) = "penalty_billing";
            return;
        }
    }

    # Step 3: Call ACM Detection Engine for deep analysis
    $var(acm_payload) = '{"call_id":"' + $ci + '","caller_id":"' + $fU + '","called_number":"' + $rU + '","source_ip":"' + $si + '","source_port":' + $sp + ',"source_group":' + $var(src_grp) + ',"p_asserted_identity":"' + $(hdr(P-Asserted-Identity){uri.user}) + '","from_display":"' + $(fn{s.escape.common}) + '","user_agent":"' + $(hdr(User-Agent)) + '","timestamp":"' + $Ts + '"}';

    # Async REST call to ACM engine
    $var(acm_result) = 0;
    if (!rest_post("http://acm-engine:8080/detect", "$var(acm_payload)", "application/json", "$var(body)", "$var(ct)", "$var(rcode)")) {
        xlog("L_ERR", "ACM: Detection engine unreachable\n");
        # Fail-open: allow call but log
        $avp(fraud_detected) = 0;
        return;
    }

    # Parse response
    if ($var(rcode) == 200) {
        $json(acm_response) := $var(body);
        
        if ($json(acm_response/is_fraud) == "true") {
            $avp(fraud_detected) = 1;
            $avp(fraud_type) = $json(acm_response/fraud_types[0]);
            $avp(fraud_confidence) = $json(acm_response/confidence);
            $avp(fraud_action) = $json(acm_response/action);
            
            xlog("L_WARN", "ACM: Fraud detected - Type: $avp(fraud_type), Confidence: $avp(fraud_confidence)%, Action: $avp(fraud_action)\n");
        }
    } else {
        xlog("L_ERR", "ACM: Detection engine returned error $var(rcode)\n");
    }
}

# ==== FRAUD HANDLING ROUTE ====
route[handle_fraud] {
    xlog("L_WARN", "ACM: Handling fraud for call $ci from $si - Type: $avp(fraud_type), Action: $avp(fraud_action)\n");

    switch ($avp(fraud_action)) {
        case "block":
            # Immediate block
            sl_send_reply(603, "Declined - Fraud Detected");
            # Log to CDR
            $avp(acc_extra) = "fraud_blocked:" + $avp(fraud_type);
            acc_db_request("FRAUD_BLOCK");
            exit;

        case "penalty_billing":
            # Apply international rate instead of local
            # Set header for billing system
            append_hf("X-ACM-Penalty-Billing: international\r\n");
            append_hf("X-ACM-Fraud-Type: $avp(fraud_type)\r\n");
            append_hf("X-ACM-Original-CLI: $fU\r\n");
            
            # Continue routing but flag for penalty
            xlog("L_INFO", "ACM: Applying penalty billing for call masking\n");
            break;

        case "flag":
            # Allow but flag for review
            append_hf("X-ACM-Flagged: true\r\n");
            append_hf("X-ACM-Fraud-Type: $avp(fraud_type)\r\n");
            xlog("L_INFO", "ACM: Call flagged for review\n");
            break;

        case "redirect":
            # Redirect to fraud investigation IVR
            $ru = "sip:fraud-ivr@internal.local";
            xlog("L_INFO", "ACM: Redirecting call to fraud IVR\n");
            break;

        default:
            # Unknown action - allow with warning
            xlog("L_WARN", "ACM: Unknown fraud action '$avp(fraud_action)', allowing call\n");
    }
}

# ==== MNP LOOKUP ROUTE ====
route[mnp_lookup] {
    $var(msisdn) = $rU;
    
    # Check DragonflyDB cache first
    if (cache_fetch("acm", "mnp:$var(msisdn)", $avp(mnp_result))) {
        xlog("L_DBG", "MNP: Cache hit for $var(msisdn) -> $avp(mnp_result)\n");
    } else {
        # Call MNP service
        $var(mnp_payload) = '{"msisdn":"' + $var(msisdn) + '"}';
        
        if (rest_post("http://acm-engine:8080/mnp/lookup", "$var(mnp_payload)", "application/json", "$var(body)", "$var(ct)", "$var(rcode)")) {
            if ($var(rcode) == 200) {
                $json(mnp) := $var(body);
                $avp(mnp_result) = $json(mnp/routing_number);
                $avp(mnp_network) = $json(mnp/network_id);
                
                # Cache for 24 hours
                cache_store("acm", "mnp:$var(msisdn)", "$avp(mnp_result)", 86400);
                
                xlog("L_INFO", "MNP: Lookup $var(msisdn) -> Network: $avp(mnp_network), RN: $avp(mnp_result)\n");
            }
        }
    }
    
    # Apply routing number if ported
    if ($avp(mnp_result) != null && $avp(mnp_result) != "") {
        # Prepend routing number to called number
        $rU = $avp(mnp_result) + $rU;
        xlog("L_INFO", "MNP: Applied routing number, new rU: $rU\n");
    }
}

# ==== CALL ROUTING ROUTE ====
route[route_call] {
    # Rate limit per source IP
    if (!rl_check("source:$si", 100, "TAILDROP")) {
        xlog("L_WARN", "RATELIMIT: Source $si exceeded CPS limit\n");
        sl_send_reply(503, "Service Unavailable - Rate Limited");
        exit;
    }

    # Use dynamic routing
    if (!do_routing()) {
        xlog("L_ERR", "ROUTING: No route found for $rU\n");
        sl_send_reply(404, "No Route Found");
        exit;
    }

    # Add record route
    record_route();

    # Relay to next hop
    if (!t_relay()) {
        sl_reply_error();
    }
}

# ==== FAILURE ROUTE ====
failure_route[gw_failure] {
    if (t_was_cancelled()) {
        exit;
    }

    # Try next gateway if available
    if (t_check_status("5[0-9][0-9]|408|6[0-9][0-9]")) {
        xlog("L_WARN", "GW_FAILURE: Gateway failed with $T_reply_code, trying next\n");
        
        if (use_next_gw()) {
            t_on_failure("gw_failure");
            t_relay();
            exit;
        }
    }

    # No more gateways
    t_reply(503, "Service Unavailable");
}

# ==== BRANCH ROUTE ====
branch_route[per_branch] {
    xlog("L_INFO", "BRANCH: New branch to $ru\n");
}

# ==== ONREPLY ROUTE ====
onreply_route[global] {
    # Handle NAT for replies
    if (isflagset(NAT) && nat_uac_test(1)) {
        fix_nated_contact();
    }
}

# ==== LOCAL ROUTE (ACK/CANCEL) ====
local_route {
    if (is_method("BYE")) {
        # Add CDR end time
        acc_db_request("BYE");
    }
}

####### Statistics #######

# Custom statistics for ACM
statistics {
    stat("acm_calls_total", "Total calls processed");
    stat("acm_fraud_detected", "Fraud events detected");
    stat("acm_fraud_blocked", "Calls blocked due to fraud");
    stat("acm_penalty_billing", "Calls with penalty billing");
    stat("acm_mnp_lookups", "MNP lookups performed");
    stat("acm_cache_hits", "Cache hit count");
    stat("acm_engine_errors", "ACM engine connection errors");
}
