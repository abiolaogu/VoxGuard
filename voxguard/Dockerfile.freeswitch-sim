# FreeSWITCH Event Simulator for Testing
# Generates realistic SIP call events for fraud detection testing

FROM python:3.11-slim

WORKDIR /app

# Install dependencies
RUN pip install --no-cache-dir asyncio aiohttp

# Copy simulator script
COPY <<'EOF' /app/freeswitch_sim.py
#!/usr/bin/env python3
"""
FreeSWITCH Event Socket Layer Simulator

Generates realistic call events for testing the fraud detection system.
Supports both normal traffic and attack simulation.
"""

import asyncio
import json
import random
import string
import time
import os
from datetime import datetime

class FreeSWITCHSimulator:
    def __init__(self, host='0.0.0.0', port=8021, password='ClueCon'):
        self.host = host
        self.port = port
        self.password = password
        self.clients = []
        self.running = False
        self.call_counter = 0

    async def handle_client(self, reader, writer):
        """Handle ESL client connection"""
        addr = writer.get_extra_info('peername')
        print(f"[ESL] Client connected: {addr}")
        self.clients.append(writer)

        # Send content-type header
        writer.write(b"Content-Type: auth/request\n\n")
        await writer.drain()

        try:
            while self.running:
                data = await asyncio.wait_for(reader.read(1024), timeout=1.0)
                if not data:
                    break

                message = data.decode().strip()
                await self.handle_message(message, writer)

        except asyncio.TimeoutError:
            pass
        except Exception as e:
            print(f"[ESL] Error: {e}")
        finally:
            self.clients.remove(writer)
            writer.close()
            await writer.wait_closed()
            print(f"[ESL] Client disconnected: {addr}")

    async def handle_message(self, message, writer):
        """Handle incoming ESL commands"""
        if message.startswith('auth '):
            pwd = message.split(' ', 1)[1]
            if pwd == self.password:
                writer.write(b"Content-Type: command/reply\nReply-Text: +OK accepted\n\n")
            else:
                writer.write(b"Content-Type: command/reply\nReply-Text: -ERR invalid\n\n")
            await writer.drain()

        elif message.startswith('event plain'):
            writer.write(b"Content-Type: command/reply\nReply-Text: +OK event listener enabled plain\n\n")
            await writer.drain()

        elif message.startswith('api uuid_kill'):
            # Handle disconnect command
            parts = message.split()
            if len(parts) >= 3:
                uuid = parts[2]
                print(f"[ESL] Disconnect command received for: {uuid}")
            writer.write(b"Content-Type: api/response\nContent-Length: 3\n\n+OK")
            await writer.drain()

    def generate_uuid(self):
        """Generate FreeSWITCH-style UUID"""
        return '-'.join([
            ''.join(random.choices(string.hexdigits.lower(), k=8)),
            ''.join(random.choices(string.hexdigits.lower(), k=4)),
            ''.join(random.choices(string.hexdigits.lower(), k=4)),
            ''.join(random.choices(string.hexdigits.lower(), k=4)),
            ''.join(random.choices(string.hexdigits.lower(), k=12))
        ])

    def generate_phone(self, prefix='+1'):
        """Generate random phone number"""
        return f"{prefix}{random.randint(2000000000, 9999999999)}"

    def create_channel_event(self, event_name, uuid, caller, destination):
        """Create FreeSWITCH channel event"""
        timestamp = int(time.time() * 1000000)  # microseconds

        event = f"""Event-Name: {event_name}
Core-UUID: {self.generate_uuid()}
FreeSWITCH-Hostname: freeswitch-sim
FreeSWITCH-Switchname: freeswitch-sim
FreeSWITCH-IPv4: 172.28.0.10
Event-Date-Timestamp: {timestamp}
Unique-ID: {uuid}
Call-Direction: inbound
Caller-Caller-ID-Number: {caller}
Caller-Destination-Number: {destination}
Channel-State: CS_INIT
Channel-State-Number: 1

"""
        return event.encode()

    async def broadcast_event(self, event):
        """Send event to all connected clients"""
        for client in self.clients:
            try:
                client.write(event)
                await client.drain()
            except Exception as e:
                print(f"[ESL] Broadcast error: {e}")

    async def generate_normal_traffic(self, cps=10):
        """Generate normal call traffic"""
        while self.running:
            uuid = self.generate_uuid()
            caller = self.generate_phone()
            destination = self.generate_phone('+1800')

            # CHANNEL_CREATE event
            event = self.create_channel_event('CHANNEL_CREATE', uuid, caller, destination)
            await self.broadcast_event(event)

            self.call_counter += 1

            # Random call duration before hangup
            await asyncio.sleep(random.uniform(0.5, 5.0))

            # CHANNEL_HANGUP event
            event = self.create_channel_event('CHANNEL_HANGUP', uuid, caller, destination)
            await self.broadcast_event(event)

            # Rate limiting
            await asyncio.sleep(1.0 / cps)

    async def generate_attack(self, target_b, num_callers=5, delay=0.1):
        """Generate multicall masking attack"""
        print(f"[ATTACK] Starting attack on {target_b} with {num_callers} callers")

        for i in range(num_callers):
            uuid = self.generate_uuid()
            caller = self.generate_phone()

            event = self.create_channel_event('CHANNEL_CREATE', uuid, caller, target_b)
            await self.broadcast_event(event)

            await asyncio.sleep(delay)

        print(f"[ATTACK] Attack complete on {target_b}")

    async def run_server(self):
        """Start the ESL server"""
        self.running = True
        server = await asyncio.start_server(
            self.handle_client, self.host, self.port
        )

        addr = server.sockets[0].getsockname()
        print(f"[ESL] Server listening on {addr}")

        async with server:
            await server.serve_forever()

    async def run_with_traffic(self, cps=10, attack_interval=30):
        """Run server with traffic generation"""
        self.running = True

        # Start server
        server_task = asyncio.create_task(self.run_server())

        # Wait for clients
        await asyncio.sleep(5)

        # Start normal traffic
        traffic_task = asyncio.create_task(self.generate_normal_traffic(cps))

        # Periodic attacks
        async def periodic_attacks():
            while self.running:
                await asyncio.sleep(attack_interval)
                target = self.generate_phone('+1555')
                await self.generate_attack(target)

        attack_task = asyncio.create_task(periodic_attacks())

        await asyncio.gather(server_task, traffic_task, attack_task)


if __name__ == '__main__':
    import sys

    cps = int(os.environ.get('TRAFFIC_CPS', '10'))
    attack_interval = int(os.environ.get('ATTACK_INTERVAL', '30'))

    simulator = FreeSWITCHSimulator()

    print("[ESL] FreeSWITCH Simulator Starting...")
    print(f"[ESL] Traffic CPS: {cps}")
    print(f"[ESL] Attack Interval: {attack_interval}s")

    asyncio.run(simulator.run_with_traffic(cps, attack_interval))
EOF

# Make executable
RUN chmod +x /app/freeswitch_sim.py

EXPOSE 8021 5060/udp 5060/tcp

CMD ["python", "/app/freeswitch_sim.py"]
