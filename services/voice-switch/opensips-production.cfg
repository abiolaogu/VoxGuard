####### OpenSIPS Production Configuration #######
####### VoxGuard Voice Switch - High Availability #######
####### Version: 3.0 | Date: 2026-02-03 #######

####### Global Parameters #######

# Logging
log_level=3
log_stderror=no
log_facility=LOG_LOCAL0
xlog_buf_size=8192

# Process management - Production tuning
children=32                          # Increased for production
auto_scaling_profile=PRODUCTION
auto_scaling_cycle=5
auto_scaling_terminate_after=30

# Network listeners - Multi-interface support
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061
listen=ws:0.0.0.0:8080               # WebSocket for WebRTC
listen=wss:0.0.0.0:8443              # Secure WebSocket

# TLS settings - Production security
tls_verify_server=1
tls_verify_client=0
tls_require_client_certificate=0
tls_method=TLSv1_3
tls_certificate=/etc/opensips/tls/server.crt
tls_private_key=/etc/opensips/tls/server.key
tls_ca_list=/etc/opensips/tls/ca.crt
tls_crl=/etc/opensips/tls/crl.pem

# Memory and performance tuning
shm_mem_size=512                     # 512MB shared memory
pkg_mem_size=16                      # 16MB per process
tcp_accept_aliases=no
tcp_connect_timeout=3
tcp_connection_lifetime=300
tcp_max_connections=8192
tcp_keepalive=1
tcp_keepidle=60
tcp_keepinterval=30
tcp_keepcount=5
tcp_no_connect=yes                   # Async TCP

# DNS settings
dns=no
rev_dns=no
dns_try_ipv6=no
use_dns_cache=on
dns_cache_del_nonexp=yes
dns_cache_mem_size=2
dns_cache_gc_interval=120

# Server identification
user_agent_header="VoxGuard-Switch/3.0"
server_header="VoxGuard-Switch/3.0"

####### Modules Section #######

# Core SIP modules
loadmodule "signaling.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "sipmsgops.so"
loadmodule "uri.so"
loadmodule "db_postgres.so"

# Dialog and accounting
loadmodule "dialog.so"
loadmodule "acc.so"

# Authentication and permissions
loadmodule "auth.so"
loadmodule "permissions.so"
loadmodule "drouting.so"
loadmodule "dispatcher.so"

# NAT handling
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"

# HTTP, REST, and JSON
loadmodule "rest_client.so"
loadmodule "json.so"
loadmodule "httpd.so"

# Caching and rate limiting
loadmodule "cachedb_redis.so"
loadmodule "ratelimit.so"
loadmodule "pike.so"

# Statistics, tracing, and management
loadmodule "statistics.so"
loadmodule "siptrace.so"
loadmodule "mi_fifo.so"
loadmodule "mi_http.so"

# Load balancing and failover
loadmodule "load_balancer.so"

# WebSocket support
loadmodule "proto_ws.so"
loadmodule "proto_wss.so"

####### Module Parameters #######

# TM parameters - Production tuning
modparam("tm", "fr_timeout", 10)
modparam("tm", "fr_inv_timeout", 120)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Trying")
modparam("tm", "unix_tx_timeout", 5)
modparam("tm", "remap_503_500", 1)

# RR parameters
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Dialog parameters with Redis backend
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 3)              # Real-time + caching
modparam("dialog", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("dialog", "profiles_with_value", "caller;gateway")
modparam("dialog", "cachedb_url", "redis://dragonfly:6379/")
modparam("dialog", "timeout_avp", "$avp(dialog_timeout)")
modparam("dialog", "default_timeout", 43200)  # 12 hours max

# Permissions (Gateway Groups)
modparam("permissions", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("permissions", "address_table", "address")

# Dynamic Routing with failover
modparam("drouting", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("drouting", "use_domain", 0)
modparam("drouting", "sort_order", 1)
modparam("drouting", "force_dns", 0)

# Dispatcher - Load balancing ACM detection engines
modparam("dispatcher", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 3)         # Proactive + on-failure
modparam("dispatcher", "ds_probing_threshold", 2)    # 2 failures = inactive
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=501")
modparam("dispatcher", "ds_hash_size", 10)
modparam("dispatcher", "ds_default_socket", "udp:0.0.0.0:5060")

# Load Balancer - Distribute calls across media gateways
modparam("load_balancer", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("load_balancer", "probing_interval", 30)
modparam("load_balancer", "probing_method", "OPTIONS")
modparam("load_balancer", "probing_from", "sip:probe@voxguard.local")
modparam("load_balancer", "probing_reply_codes", "501,403,404,200")

# ACC (CDR accounting)
modparam("acc", "db_url", "postgres://opensips:CHANGE_ME@yugabyte:5433/opensips")
modparam("acc", "early_media", 1)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 1)
modparam("acc", "db_flag", "ACC_DB")
modparam("acc", "db_missed_flag", "ACC_MISSED")
modparam("acc", "cdr_flag", "CDR")
modparam("acc", "db_extra",
    "caller_id=$fU;called_number=$rU;source_ip=$si;fraud_detected=$avp(fraud_detected);fraud_type=$avp(fraud_type);gateway_id=$avp(gw_id);circuit_breaker_state=$avp(cb_state)")

# DragonflyDB cache
modparam("cachedb_redis", "cachedb_url", "redis:acm://dragonfly:6379/")
modparam("cachedb_redis", "connect_timeout", 500)
modparam("cachedb_redis", "query_timeout", 1000)

# REST client for ACM Detection Engine with circuit breaker support
modparam("rest_client", "connection_timeout", 200)   # 200ms connect
modparam("rest_client", "curl_timeout", 800)         # 800ms total
modparam("rest_client", "max_async_transfers", 512)
modparam("rest_client", "max_transfer_size", 16384)

# Rate limiting with cache backend
modparam("ratelimit", "timer_interval", 1)
modparam("ratelimit", "default_algorithm", "SBT")
modparam("ratelimit", "cachedb_url", "redis:acm://dragonfly:6379/")
modparam("ratelimit", "pipe_replication_cluster", "acm_prod_cluster")

# Pike (anti-flood) - Production tuning
modparam("pike", "sampling_time_unit", 1)
modparam("pike", "reqs_density_per_unit", 150)       # Higher for production
modparam("pike", "remove_latency", 300)
modparam("pike", "pike_log_level", 1)

# SIP tracing (Homer)
modparam("siptrace", "trace_id", "[tid]homer_hep")
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "traced_user_avp", "$avp(traced_user)")

# MI HTTP interface for management
modparam("mi_http", "mi_http_port", 8888)
modparam("mi_http", "mi_http_root", "mi")

# HTTPD for health checks
modparam("httpd", "port", 8888)

####### Routing Logic #######

# Circuit breaker state cache keys
# cb:acm:state = CLOSED|OPEN|HALF_OPEN
# cb:acm:failures = failure count
# cb:acm:last_failure = timestamp
# cb:acm:next_retry = timestamp

route {
    # Initial sanity checks
    if (!mf_process_maxfwd_header(15)) {
        sl_send_reply(483, "Too Many Hops");
        exit;
    }

    # Anti-flood protection
    if (!pike_check_req()) {
        xlog("L_WARN", "PIKE: Flood detected from $si\n");
        sl_send_reply(503, "Service Unavailable - Rate Limited");
        exit;
    }

    # NAT detection and handling
    force_rport();
    if (nat_uac_test(19)) {
        fix_nated_contact();
        setflag(NAT);
    }

    # Record route for in-dialog requests
    if (has_totag()) {
        if (is_method("INVITE|UPDATE")) {
            record_route();
        }
        route(sequential);
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Initial request processing
    t_check_trans();

    # Health check - respond locally
    if (is_method("OPTIONS") && ($rU == "health" || $rU == "")) {
        sl_send_reply(200, "OK - VoxGuard Switch Active");
        exit;
    }

    # INVITE processing - main fraud detection path
    if (is_method("INVITE")) {
        # Create dialog for CDR
        create_dialog();
        setflag(CDR);
        setflag(ACC_DB);

        # Set dialog timeout from caller profile
        $avp(dialog_timeout) = 3600;  # Default 1 hour

        # ==== ANTI-CALL MASKING DETECTION WITH CIRCUIT BREAKER ====
        route(acm_detect);

        # Check if fraud was detected
        if ($avp(fraud_detected) == 1) {
            route(handle_fraud);
            exit;
        }

        # MNP lookup for Nigerian numbers
        if ($rU =~ "^234[0-9]{10}$") {
            route(mnp_lookup);
        }

        # Load balancing to media gateways
        route(route_call);
    }

    # REGISTER handling
    if (is_method("REGISTER")) {
        sl_send_reply(405, "Method Not Allowed");
        exit;
    }

    # Default reject
    sl_send_reply(501, "Not Implemented");
    exit;
}

# Sequential request handling (in-dialog)
route[sequential] {
    if (loose_route()) {
        if (is_method("BYE|CANCEL")) {
            setflag(ACC_DB);
        }

        # Handle NAT for in-dialog requests
        if (isflagset(NAT)) {
            fix_nated_contact();
        }

        t_on_failure("gw_failure");
        t_relay();
    } else {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                t_relay();
            }
        } else {
            sl_send_reply(404, "Not Found");
        }
    }
    exit;
}

# ==== CIRCUIT BREAKER IMPLEMENTATION ====
route[circuit_breaker_check] {
    # Check circuit breaker state from cache
    $var(cb_state) = "CLOSED";

    if (cache_fetch("acm", "cb:acm:state", $avp(cb_cached_state))) {
        $var(cb_state) = $avp(cb_cached_state);
    }

    $avp(cb_state) = $var(cb_state);

    # OPEN state - reject fast without calling ACM engine
    if ($var(cb_state) == "OPEN") {
        # Check if retry timeout has passed
        if (cache_fetch("acm", "cb:acm:next_retry", $avp(cb_next_retry))) {
            if ($Ts < $(avp(cb_next_retry){s.int})) {
                xlog("L_WARN", "CIRCUIT_BREAKER: OPEN - Fast failing without ACM engine\n");
                $avp(circuit_breaker_open) = 1;
                return -1;  # Fail-open: allow call without detection
            } else {
                # Transition to HALF_OPEN
                cache_store("acm", "cb:acm:state", "HALF_OPEN", 300);
                $var(cb_state) = "HALF_OPEN";
                $avp(cb_state) = "HALF_OPEN";
                xlog("L_INFO", "CIRCUIT_BREAKER: Transitioning to HALF_OPEN\n");
            }
        }
    }

    # HALF_OPEN state - allow limited traffic through
    if ($var(cb_state) == "HALF_OPEN") {
        # 10% sampling in HALF_OPEN
        if ($(RANDOM{s.int}) % 10 != 0) {
            xlog("L_INFO", "CIRCUIT_BREAKER: HALF_OPEN - Sampling, skip this call\n");
            $avp(circuit_breaker_half_open_skip) = 1;
            return -1;  # Fail-open for 90% of calls
        }
        xlog("L_INFO", "CIRCUIT_BREAKER: HALF_OPEN - Testing with this call\n");
    }

    return 1;  # Proceed with ACM engine call
}

route[circuit_breaker_success] {
    # Record successful call to ACM engine
    if ($avp(cb_state) == "HALF_OPEN") {
        # Transition back to CLOSED
        cache_store("acm", "cb:acm:state", "CLOSED", 300);
        cache_store("acm", "cb:acm:failures", "0", 300);
        cache_remove("acm", "cb:acm:next_retry");
        xlog("L_INFO", "CIRCUIT_BREAKER: HALF_OPEN -> CLOSED (success)\n");
    } else if ($avp(cb_state) == "CLOSED") {
        # Reset failure counter on success
        cache_store("acm", "cb:acm:failures", "0", 300);
    }
}

route[circuit_breaker_failure] {
    # Record failure
    $var(failures) = 0;
    if (cache_fetch("acm", "cb:acm:failures", $avp(cb_failures))) {
        $var(failures) = $(avp(cb_failures){s.int}) + 1;
    } else {
        $var(failures) = 1;
    }

    cache_store("acm", "cb:acm:failures", "$var(failures)", 300);
    cache_store("acm", "cb:acm:last_failure", "$Ts", 300);

    xlog("L_WARN", "CIRCUIT_BREAKER: Failure #$var(failures) recorded\n");

    # Threshold: 5 failures within 60 seconds
    if ($var(failures) >= 5) {
        if ($avp(cb_state) == "CLOSED" || $avp(cb_state) == "HALF_OPEN") {
            # Open circuit breaker
            cache_store("acm", "cb:acm:state", "OPEN", 300);

            # Set retry time (30 seconds from now)
            $var(next_retry) = $Ts + 30;
            cache_store("acm", "cb:acm:next_retry", "$var(next_retry)", 300);

            xlog("L_ERROR", "CIRCUIT_BREAKER: Opening circuit - Too many failures. Next retry at $var(next_retry)\n");

            # Alert monitoring
            raise_event("E_CIRCUIT_BREAKER_OPEN",
                "service", "acm-engine",
                "failures", "$var(failures)",
                "next_retry", "$var(next_retry)");
        }
    }
}

# ==== ANTI-CALL MASKING DETECTION ROUTE WITH CIRCUIT BREAKER ====
route[acm_detect] {
    $avp(fraud_detected) = 0;
    $avp(fraud_type) = "NONE";
    $avp(fraud_confidence) = 0;
    $avp(fraud_action) = "allow";
    $avp(circuit_breaker_open) = 0;

    # Step 1: Check gateway group (permissions)
    $var(src_grp) = 0;
    if (check_source_address(1)) {
        $var(src_grp) = 1;         # Trusted local carriers
    } else if (check_source_address(10)) {
        $var(src_grp) = 10;        # International gateways
    } else if (check_source_address(66)) {
        # Blacklisted
        $var(src_grp) = 66;
        xlog("L_WARN", "ACM: Blacklisted source $si attempting call\n");
        $avp(fraud_detected) = 1;
        $avp(fraud_type) = "BLACKLIST";
        $avp(fraud_confidence) = 100;
        $avp(fraud_action) = "block";
        return;
    }

    $avp(gw_id) = $var(src_grp);

    # Step 2: Fast-path CLI validation
    if ($var(src_grp) == 10) {
        if ($fU =~ "^\+?234[0-9]{10}$") {
            xlog("L_WARN", "ACM: Call masking detected! International gateway $si with Nigerian CLI $fU\n");
            $avp(fraud_detected) = 1;
            $avp(fraud_type) = "CLI_MASK";
            $avp(fraud_confidence) = 95;
            $avp(fraud_action) = "penalty_billing";
            return;
        }
    }

    # Step 3: Check circuit breaker before calling ACM engine
    if (!route(circuit_breaker_check)) {
        # Circuit breaker is OPEN or HALF_OPEN skip
        if ($avp(circuit_breaker_open) == 1) {
            xlog("L_WARN", "ACM: Circuit breaker OPEN - Failing open, allowing call\n");
            $avp(fraud_detected) = 0;
            return;
        }
        if ($avp(circuit_breaker_half_open_skip) == 1) {
            xlog("L_INFO", "ACM: Circuit breaker HALF_OPEN - Sampled out, allowing call\n");
            $avp(fraud_detected) = 0;
            return;
        }
    }

    # Step 4: Call ACM Detection Engine via dispatcher (load balanced)
    $var(acm_payload) = '{"call_id":"' + $ci + '","caller_id":"' + $fU +
        '","called_number":"' + $rU + '","source_ip":"' + $si +
        '","source_port":' + $sp + ',"source_group":' + $var(src_grp) +
        '","p_asserted_identity":"' + $(hdr(P-Asserted-Identity){uri.user}) +
        '","from_display":"' + $(fn{s.escape.common}) +
        '","user_agent":"' + $(hdr(User-Agent)) + '","timestamp":"' + $Ts + '"}';

    # Use dispatcher to load balance across ACM engine instances
    $var(acm_url) = "http://" + $dd + "/detect";

    # Select active ACM engine instance
    if (!ds_select_dst(1, 4)) {  # Set 1, Round-robin
        xlog("L_ERR", "ACM: No active detection engine available\n");
        route(circuit_breaker_failure);
        # Fail-open: allow call but log
        $avp(fraud_detected) = 0;
        return;
    }

    # REST call to selected instance
    if (!rest_post("$var(acm_url)", "$var(acm_payload)", "application/json",
                    "$var(body)", "$var(ct)", "$var(rcode)")) {
        xlog("L_ERR", "ACM: Detection engine unreachable\n");
        route(circuit_breaker_failure);

        # Mark destination as inactive
        ds_mark_dst("i");

        # Fail-open: allow call but log
        $avp(fraud_detected) = 0;
        return;
    }

    # Parse response
    if ($var(rcode) == 200) {
        route(circuit_breaker_success);

        $json(acm_response) := $var(body);

        if ($json(acm_response/is_fraud) == "true") {
            $avp(fraud_detected) = 1;
            $avp(fraud_type) = $json(acm_response/fraud_types[0]);
            $avp(fraud_confidence) = $json(acm_response/confidence);
            $avp(fraud_action) = $json(acm_response/action);

            xlog("L_WARN", "ACM: Fraud detected - Type: $avp(fraud_type), Confidence: $avp(fraud_confidence)%, Action: $avp(fraud_action)\n");
        }
    } else {
        xlog("L_ERR", "ACM: Detection engine returned error $var(rcode)\n");
        route(circuit_breaker_failure);
    }
}

# ==== FRAUD HANDLING ROUTE ====
route[handle_fraud] {
    xlog("L_WARN", "ACM: Handling fraud for call $ci - Type: $avp(fraud_type), Action: $avp(fraud_action)\n");

    switch ($avp(fraud_action)) {
        case "block":
            sl_send_reply(603, "Declined - Fraud Detected");
            acc_db_request("FRAUD_BLOCK");
            exit;

        case "penalty_billing":
            append_hf("X-ACM-Penalty-Billing: international\r\n");
            append_hf("X-ACM-Fraud-Type: $avp(fraud_type)\r\n");
            append_hf("X-ACM-Original-CLI: $fU\r\n");
            xlog("L_INFO", "ACM: Applying penalty billing\n");
            break;

        case "flag":
            append_hf("X-ACM-Flagged: true\r\n");
            append_hf("X-ACM-Fraud-Type: $avp(fraud_type)\r\n");
            xlog("L_INFO", "ACM: Call flagged for review\n");
            break;

        case "redirect":
            $ru = "sip:fraud-ivr@internal.local";
            xlog("L_INFO", "ACM: Redirecting to fraud IVR\n");
            break;

        default:
            xlog("L_WARN", "ACM: Unknown action '$avp(fraud_action)', allowing\n");
    }
}

# ==== MNP LOOKUP ROUTE ====
route[mnp_lookup] {
    $var(msisdn) = $rU;

    # Check cache first
    if (cache_fetch("acm", "mnp:$var(msisdn)", $avp(mnp_result))) {
        xlog("L_DBG", "MNP: Cache hit for $var(msisdn)\n");
    } else {
        # Call MNP service via dispatcher
        $var(mnp_payload) = '{"msisdn":"' + $var(msisdn) + '"}';

        if (ds_select_dst(2, 4)) {  # Set 2 for MNP services
            $var(mnp_url) = "http://" + $dd + "/mnp/lookup";

            if (rest_post("$var(mnp_url)", "$var(mnp_payload)", "application/json",
                         "$var(body)", "$var(ct)", "$var(rcode)")) {
                if ($var(rcode) == 200) {
                    $json(mnp) := $var(body);
                    $avp(mnp_result) = $json(mnp/routing_number);

                    # Cache for 24 hours
                    cache_store("acm", "mnp:$var(msisdn)", "$avp(mnp_result)", 86400);
                }
            }
        }
    }

    # Apply routing number if ported
    if ($avp(mnp_result) != null && $avp(mnp_result) != "") {
        $rU = $avp(mnp_result) + $rU;
        xlog("L_INFO", "MNP: Applied RN, new rU: $rU\n");
    }
}

# ==== CALL ROUTING WITH LOAD BALANCING ====
route[route_call] {
    # Rate limit per source IP
    if (!rl_check("source:$si", 200, "TAILDROP")) {
        xlog("L_WARN", "RATELIMIT: Source $si exceeded CPS limit\n");
        sl_send_reply(503, "Service Unavailable - Rate Limited");
        exit;
    }

    # Load balancing to media gateways
    # Groups: 1=premium, 2=standard, 3=budget
    $var(lb_group) = "1";  # Default to premium

    if (!load_balance($var(lb_group), "pstn", "1")) {
        xlog("L_ERR", "ROUTING: No available gateway in group $var(lb_group)\n");

        # Try fallback group
        if (!load_balance("2", "pstn", "1")) {
            sl_send_reply(503, "Service Unavailable");
            exit;
        }
    }

    # Record route
    record_route();

    # Set failure route for automatic failover
    t_on_failure("gw_failure");

    # Relay to selected gateway
    if (!t_relay()) {
        sl_reply_error();
    }
}

# ==== FAILURE ROUTE WITH AUTOMATIC FAILOVER ====
failure_route[gw_failure] {
    if (t_was_cancelled()) {
        exit;
    }

    # Try next gateway on 5xx, 408, 6xx
    if (t_check_status("5[0-9][0-9]|408|6[0-9][0-9]")) {
        xlog("L_WARN", "GW_FAILURE: Response $T_reply_code, trying next gateway\n");

        # Try next destination in load balancer
        if (load_balance("", "pstn", "1")) {
            t_on_failure("gw_failure");
            t_relay();
            exit;
        }

        # No more gateways available
        xlog("L_ERR", "GW_FAILURE: No more gateways available\n");
    }

    # Send final error to caller
    t_reply(503, "Service Unavailable");
}

# ==== BRANCH ROUTE ====
branch_route[per_branch] {
    xlog("L_INFO", "BRANCH: Routing to $ru\n");
}

# ==== ONREPLY ROUTE ====
onreply_route[global] {
    # Handle NAT for replies
    if (isflagset(NAT) && nat_uac_test(1)) {
        fix_nated_contact();
    }
}

# ==== LOCAL ROUTE ====
local_route {
    if (is_method("BYE")) {
        acc_db_request("BYE");
    }
}

# ==== EVENT ROUTE - Dispatcher Health Check ====
event_route[E_DISPATCHER_STATUS] {
    xlog("L_INFO", "DISPATCHER: Status change - Set: $param(set_id), Dest: $param(destination), State: $param(state)\n");
}

# ==== EVENT ROUTE - Load Balancer Health Check ====
event_route[E_LOAD_BALANCER_STATUS] {
    xlog("L_INFO", "LOAD_BALANCER: Status change - Group: $param(group), Dest: $param(uri), State: $param(status)\n");
}

####### Statistics #######

statistics {
    stat("acm_calls_total", "Total calls processed");
    stat("acm_fraud_detected", "Fraud events detected");
    stat("acm_fraud_blocked", "Calls blocked due to fraud");
    stat("acm_penalty_billing", "Calls with penalty billing");
    stat("acm_circuit_breaker_open", "Circuit breaker open events");
    stat("acm_circuit_breaker_closed", "Circuit breaker closed events");
    stat("acm_failover_events", "Gateway failover events");
    stat("acm_load_balanced", "Load balanced calls");
}
