package service

import (
	"context"
	"testing"
	"time"

	"github.com/billyronks/acm-management-api/internal/domain/security/entity"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.uber.org/zap"
)

// Test LogEvent - Success
func TestLogEvent_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	event := entity.AuditEvent{
		UserID:       "user-123",
		Username:     "john.doe",
		Action:       "create",
		ResourceType: "gateway",
		ResourceID:   "gw-456",
		ResourceName: "Gateway 1",
		Status:       entity.StatusSuccess,
		Severity:     entity.SeverityMedium,
		IPAddress:    "192.168.1.1",
		UserAgent:    "Mozilla/5.0",
	}

	mockRepo.On("CreateAuditEvent", ctx, mock.AnythingOfType("*entity.AuditEvent")).Return(nil)

	err := service.LogEvent(ctx, event)

	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

// Test LogEvent - Auto-generated fields
func TestLogEvent_AutoGeneratedFields(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	event := entity.AuditEvent{
		UserID:       "user-123",
		Action:       "create",
		ResourceType: "gateway",
		// ID, Timestamp, Status, and Severity should be auto-generated
	}

	mockRepo.On("CreateAuditEvent", ctx, mock.MatchedBy(func(e *entity.AuditEvent) bool {
		return e.ID != "" &&
			!e.Timestamp.IsZero() &&
			e.Status == entity.StatusSuccess &&
			e.Severity == entity.SeverityLow
	})).Return(nil)

	err := service.LogEvent(ctx, event)

	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

// Test LogAuthEvent - Success
func TestLogAuthEvent_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()

	mockRepo.On("CreateAuditEvent", ctx, mock.MatchedBy(func(e *entity.AuditEvent) bool {
		return e.UserID == "user-123" &&
			e.Username == "john.doe" &&
			e.Action == "login_success" &&
			e.ResourceType == "auth" &&
			e.Status == entity.StatusSuccess &&
			e.Severity == entity.SeverityLow
	})).Return(nil)

	service.LogAuthEvent(ctx, "user-123", "john.doe", "login_success", "192.168.1.1", "Mozilla/5.0", true, "")

	mockRepo.AssertExpectations(t)
}

// Test LogAuthEvent - Failure with high severity
func TestLogAuthEvent_AccountLocked(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()

	mockRepo.On("CreateAuditEvent", ctx, mock.MatchedBy(func(e *entity.AuditEvent) bool {
		return e.Action == "account_locked" &&
			e.Status == entity.StatusFailure &&
			e.Severity == entity.SeverityHigh
	})).Return(nil)

	service.LogAuthEvent(ctx, "user-123", "john.doe", "account_locked", "192.168.1.1", "Mozilla/5.0", false, "Too many attempts")

	mockRepo.AssertExpectations(t)
}

// Test QueryAuditLogs - Success
func TestQueryAuditLogs_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	startTime := time.Now().AddDate(0, 0, -7)
	endTime := time.Now()

	filter := entity.AuditFilter{
		UserID:    "user-123",
		StartTime: startTime,
		EndTime:   endTime,
	}

	expectedEvents := []*entity.AuditEvent{
		{ID: "event-1", UserID: "user-123", Action: "login_success"},
		{ID: "event-2", UserID: "user-123", Action: "create"},
	}

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 50).
		Return(expectedEvents, 2, nil)

	events, total, err := service.QueryAuditLogs(ctx, filter, 1, 50)

	assert.NoError(t, err)
	assert.Equal(t, 2, total)
	assert.Len(t, events, 2)
	assert.Equal(t, "event-1", events[0].ID)
	mockRepo.AssertExpectations(t)
}

// Test QueryAuditLogs - Default pagination
func TestQueryAuditLogs_DefaultPagination(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	filter := entity.AuditFilter{}

	mockRepo.On("QueryAuditEvents", ctx, mock.MatchedBy(func(f entity.AuditFilter) bool {
		// Should set default time range (last 30 days)
		return !f.StartTime.IsZero() && !f.EndTime.IsZero()
	}), 1, 50).Return([]*entity.AuditEvent{}, 0, nil)

	_, _, err := service.QueryAuditLogs(ctx, filter, 0, 0) // Invalid pagination values

	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

// Test QueryAuditLogs - Max page size enforcement
func TestQueryAuditLogs_MaxPageSize(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	filter := entity.AuditFilter{}

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 50).
		Return([]*entity.AuditEvent{}, 0, nil)

	_, _, err := service.QueryAuditLogs(ctx, filter, 1, 200) // Request 200 items

	assert.NoError(t, err)
	// Should cap at 50
	mockRepo.AssertExpectations(t)
}

// Test GetAuditStats - Success
func TestGetAuditStats_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	startTime := time.Now().AddDate(0, 0, -30)
	endTime := time.Now()

	expectedStats := &entity.AuditStats{
		TotalEvents:     1000,
		SuccessEvents:   950,
		FailureEvents:   50,
		UniqueUsers:     25,
		TopActions:      map[string]int{"login_success": 500, "create": 300},
		TopResources:    map[string]int{"gateway": 400, "fraud_alert": 350},
		SeverityBreakup: map[string]int{"low": 800, "medium": 150, "high": 50},
	}

	mockRepo.On("GetAuditStats", ctx, startTime, endTime).Return(expectedStats, nil)

	stats, err := service.GetAuditStats(ctx, startTime, endTime)

	assert.NoError(t, err)
	assert.NotNil(t, stats)
	assert.Equal(t, 1000, stats.TotalEvents)
	assert.Equal(t, 950, stats.SuccessEvents)
	assert.NotEmpty(t, stats.Period)
	assert.NotZero(t, stats.GeneratedAt)
	mockRepo.AssertExpectations(t)
}

// Test GetUserActivity - Success
func TestGetUserActivity_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	userID := "user-123"

	expectedEvents := []*entity.AuditEvent{
		{ID: "event-1", UserID: userID, Action: "login_success"},
		{ID: "event-2", UserID: userID, Action: "create"},
		{ID: "event-3", UserID: userID, Action: "update"},
	}

	mockRepo.On("QueryAuditEvents", ctx, mock.MatchedBy(func(f entity.AuditFilter) bool {
		return f.UserID == userID
	}), 1, 50).Return(expectedEvents, 3, nil)

	events, err := service.GetUserActivity(ctx, userID, 50)

	assert.NoError(t, err)
	assert.Len(t, events, 3)
	assert.Equal(t, userID, events[0].UserID)
	mockRepo.AssertExpectations(t)
}

// Test GetUserActivity - Limit enforcement
func TestGetUserActivity_LimitEnforcement(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	userID := "user-123"

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 50).
		Return([]*entity.AuditEvent{}, 0, nil)

	_, err := service.GetUserActivity(ctx, userID, 200) // Request 200 items

	assert.NoError(t, err)
	// Should cap at 50
	mockRepo.AssertExpectations(t)
}

// Test LogSecurityEvent - Success
func TestLogSecurityEvent_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	event := entity.SecurityEvent{
		EventType:   "unauthorized_access_attempt",
		Severity:    entity.SeverityHigh,
		UserID:      "user-123",
		IPAddress:   "192.168.1.100",
		UserAgent:   "Mozilla/5.0",
		Description: "Attempt to access restricted resource",
	}

	mockRepo.On("CreateSecurityEvent", ctx, mock.AnythingOfType("*entity.SecurityEvent")).Return(nil)
	mockRepo.On("CreateAuditEvent", ctx, mock.AnythingOfType("*entity.AuditEvent")).Return(nil)

	err := service.LogSecurityEvent(ctx, event)

	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

// Test GetSecurityEvents - Success
func TestGetSecurityEvents_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	eventType := "unauthorized_access_attempt"
	severity := entity.SeverityHigh
	resolved := false

	expectedEvents := []*entity.SecurityEvent{
		{ID: "sec-1", EventType: eventType, Severity: severity, IsResolved: false},
		{ID: "sec-2", EventType: eventType, Severity: severity, IsResolved: false},
	}

	mockRepo.On("QuerySecurityEvents", ctx, eventType, severity, &resolved, 1, 50).
		Return(expectedEvents, 2, nil)

	events, total, err := service.GetSecurityEvents(ctx, eventType, severity, &resolved, 1, 50)

	assert.NoError(t, err)
	assert.Equal(t, 2, total)
	assert.Len(t, events, 2)
	assert.False(t, events[0].IsResolved)
	mockRepo.AssertExpectations(t)
}

// Test ResolveSecurityEvent - Success
func TestResolveSecurityEvent_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	eventID := "sec-123"
	resolvedBy := "admin-456"
	note := "False positive - verified legitimate access"

	existingEvent := &entity.SecurityEvent{
		ID:         eventID,
		EventType:  "unauthorized_access_attempt",
		IsResolved: false,
	}

	mockRepo.On("GetSecurityEventByID", ctx, eventID).Return(existingEvent, nil)
	mockRepo.On("UpdateSecurityEvent", ctx, mock.MatchedBy(func(e *entity.SecurityEvent) bool {
		return e.ID == eventID && e.IsResolved && e.ResolvedBy != nil && *e.ResolvedBy == resolvedBy
	})).Return(nil)
	mockRepo.On("CreateAuditEvent", ctx, mock.AnythingOfType("*entity.AuditEvent")).Return(nil)

	err := service.ResolveSecurityEvent(ctx, eventID, resolvedBy, note)

	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

// Test ResolveSecurityEvent - Already resolved
func TestResolveSecurityEvent_AlreadyResolved(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	eventID := "sec-123"
	resolvedBy := "admin-456"
	note := "Test note"

	existingEvent := &entity.SecurityEvent{
		ID:         eventID,
		EventType:  "unauthorized_access_attempt",
		IsResolved: true, // Already resolved
	}

	mockRepo.On("GetSecurityEventByID", ctx, eventID).Return(existingEvent, nil)

	err := service.ResolveSecurityEvent(ctx, eventID, resolvedBy, note)

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "already resolved")
	mockRepo.AssertExpectations(t)
}

// Test ExportAuditLogs - JSON format
func TestExportAuditLogs_JSON(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	filter := entity.AuditFilter{
		UserID: "user-123",
	}

	events := []*entity.AuditEvent{
		{ID: "event-1", UserID: "user-123", Action: "login_success"},
		{ID: "event-2", UserID: "user-123", Action: "create"},
	}

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 10000).
		Return(events, 2, nil)

	data, err := service.ExportAuditLogs(ctx, filter, "json")

	assert.NoError(t, err)
	assert.NotEmpty(t, data)
	assert.Contains(t, string(data), "event-1")
	assert.Contains(t, string(data), "login_success")
	mockRepo.AssertExpectations(t)
}

// Test ExportAuditLogs - CSV format
func TestExportAuditLogs_CSV(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	filter := entity.AuditFilter{
		UserID: "user-123",
	}

	events := []*entity.AuditEvent{
		{
			ID:           "event-1",
			UserID:       "user-123",
			Username:     "john.doe",
			Action:       "login_success",
			ResourceType: "auth",
			ResourceID:   "user-123",
			Status:       entity.StatusSuccess,
			Severity:     entity.SeverityLow,
			IPAddress:    "192.168.1.1",
			Timestamp:    time.Now(),
		},
	}

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 10000).
		Return(events, 1, nil)

	data, err := service.ExportAuditLogs(ctx, filter, "csv")

	assert.NoError(t, err)
	assert.NotEmpty(t, data)
	csvString := string(data)
	assert.Contains(t, csvString, "ID,Timestamp,User ID,Username,Action")
	assert.Contains(t, csvString, "event-1")
	assert.Contains(t, csvString, "john.doe")
	mockRepo.AssertExpectations(t)
}

// Test ExportAuditLogs - Unsupported format
func TestExportAuditLogs_UnsupportedFormat(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	filter := entity.AuditFilter{
		UserID: "user-123",
	}

	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 10000).
		Return([]*entity.AuditEvent{}, 0, nil)

	data, err := service.ExportAuditLogs(ctx, filter, "xml")

	assert.Error(t, err)
	assert.Nil(t, data)
	assert.Contains(t, err.Error(), "unsupported format")
	mockRepo.AssertExpectations(t)
}

// Test GenerateComplianceReport - Success
func TestGenerateComplianceReport_Success(t *testing.T) {
	mockRepo := new(MockSecurityRepository)
	logger := zap.NewNop()

	service := NewAuditService(mockRepo, logger)

	ctx := context.Background()
	startDate := time.Now().AddDate(0, 0, -30)
	endDate := time.Now()

	stats := &entity.AuditStats{
		TotalEvents:   1000,
		SuccessEvents: 950,
		FailureEvents: 50,
	}

	mockRepo.On("GetAuditStats", ctx, startDate, endDate).Return(stats, nil)
	mockRepo.On("QueryAuditEvents", ctx, mock.AnythingOfType("entity.AuditFilter"), 1, 1000).
		Return([]*entity.AuditEvent{}, 0, nil).Times(3) // Called 3 times for different filters

	report, err := service.GenerateComplianceReport(ctx, startDate, endDate)

	assert.NoError(t, err)
	assert.NotNil(t, report)
	assert.Contains(t, report, "report_period")
	assert.Contains(t, report, "statistics")
	assert.Contains(t, report, "compliance_status")
	assert.Contains(t, report, "high_severity_events")
	assert.Contains(t, report, "critical_events")
	assert.Contains(t, report, "failed_authentication_attempts")

	complianceStatus := report["compliance_status"].(map[string]interface{})
	assert.True(t, complianceStatus["ncc_icl_compliant"].(bool))
	assert.Equal(t, "7 years", complianceStatus["retention_period"])

	mockRepo.AssertExpectations(t)
}
